#                     编译原理第一次报告

## 我的工作

   我参与了词法分析的全部，并且设计了符号表，同时本人还将组员的由内存保存的转化为有数据库存储的。

  本人的难度不在于思路上而在于将所有组员的代码改变格式，变为数据库存储。

  在最后几天本人准备将所有的代码进行一个整合，并将界面加入。

## 目前的困难

主要是时间紧张，有一点来不及，不知道界面能不能做完

## debug的过程

   本人负责将所有组员的代码进行debug，在debug的过程中遇到了很多的问题，在一开始本人发现组员的代码大多变量名字有很多的冲突，本人只能逐个进行填写，并且逐个进行派排查，这项任务的难度较大，耗费的时间较长。

   本人的第二个难度在于将所有的内容改为数据库，数据库的sql语句在c语言的api中，比较容易发生错误，因为本人的sql语句debug使用了较长的时间，并且由于需要和组员的代码保持一样的功能，本人需要先十分明确组员代码的功能，然后才能进行编写。

   本人的第三个难度在于各个组员使用的编译器不同，因此对代码的要求也不同，在动态数组的 使用上面，vs关于动态数组的使用就一定要求先有一个元素，然后才能进行才做，而codeblocks则不需要，因此在合并的时候，不同人的编码习惯，会产生很多麻烦。

   本人的第四个难度，在于组员之间的合作，因为是在家进行课设，无法见面，无法交流进度，导致每个人做的比较自闭，缺少交流，导致合并的时候有问题 

## 源代码



/*#define  _CRT_SECURE_NO_DEPRECATE
#include <iostream>
#include<math.h>
#include<string>
#include<fstream>
#include<windows.h>
#include"mysql.h"
using namespace std;
typedef struct T   //线性表定义
{
	char t1;
	int t2;
}List[1000];

int c2;     //用于语法分析中等于线性表中t2
char c1;    //用于语法分析中等于线性表中t1
List Token;     //线性表，存储token序列
static int n1 = 0;     //线性表元素下标1
static int n2 = 0;     //线性表元素下标2
FILE* fp;
char token[10];
char ch;
int i = 0;          //token下标
int state;			//存放状态标记
int code1;       //token类别码,1->IT,3->CT,3->KT,4->CHT,5->ST,6->PT
int code2;       //表内序号
int state_before;
int num;
MYSQL m_sqlconnect;
MYSQL_RES* m_res;
int numi = 0, numc = 0, numch = 0, nums = 0;    //存放IT,CT,CHT,ST表中的元素数量。
int namenumber = 1;
int constnumber = 1;
int charnumber = 1;
int  stringnumber = 1;
int  delimiternumber= 1;
//string PT[18] = { "<=", "==", "=", ">", "<", "+", "-", "*", "/",",", ";", "(", ")", "[", "]",":","&","|" };
//string KT[12] = { "integer", "float", "bool", "char", "program", "if","else","begin","end",
				//"var","while","arrary" };
//string IT[20];//字符串
//string CT[20];//常数
//string CHT[20];//字符表
//string ST[20];//字符串表
int state_change(int state, char ch);   //识别器
void state_to_code(int state_before, char* token);    //词法分析器
int weatherletter(char c);         //判断字母
int weatherinteger(char c);        //判断数字
void ID_SEQUENCE();
void SUB_PROGRAM();
void TYPE();
void EXPRESSION();
void COM_SENTENCE();
void SEN_SEQUENCE();
void EVA_SENTENCE();
void BOOL_EXPRESSION();
void IF_SENTENCE();
void WHILE_SENTENCE();
void EXP();
void TERM();
void FACTOR();
void IF1();
void EXP1();

bool connect()//建立连接
{
	mysql_init(&m_sqlconnect);
	if (!mysql_real_connect(&m_sqlconnect, "localhost", "root", "123456", "mysql", 3306, NULL, 0))
	{
		cout << "Error connecting to database" << endl;
		return false;
	}
	else
	{
		//cout << "connected" << endl;
		return true;
	}
}
void freeconnect()//释放资源
{
	mysql_close(&m_sqlconnect);
	mysql_free_result(m_res);
}
bool Whethersp(string ch)
{
	connect();
	string sql3 = "SELECT * FROM imooc.delimiter WHERE delimiter = ";
	string sql1 = "\"";
	string sql2 = "\"";
	string sql4 = ";";
	string sql = sql3 + sql2 + ch + sql1 + sql4;
	//cout << sql;
	if ((mysql_query(&m_sqlconnect, sql.c_str())) == 0)
	{
		MYSQL_ROW row;
		m_res = mysql_store_result(&m_sqlconnect);
		while (row = mysql_fetch_row(m_res))
		{
			if (row != NULL)
			{
				cout << "(p,";
				cout << row[1] << ")" << endl;
				freeconnect();
				Token[n1].t1 = 'p';
				Token[n1].t2 = int(atof(row[1]));
				n1++;
				return true;
			}
		}
		freeconnect();
		return false;
	}
	else
	{
		cout << mysql_error(&m_sqlconnect);
	}
}
bool Whetherkeyword(string word)
{
	connect();
	string sql3 = "SELECT * FROM imooc.keyword WHERE temp =";
	string sql1 = "\"";
	string sql2 = "\"";
	string sql4 = ";";
	string sql = sql3 + sql1 + word + sql2 + sql4;
	//cout << sql<<endl;
	if ((mysql_query(&m_sqlconnect, sql.c_str())) == 0)
	{
		MYSQL_ROW row;
		m_res = mysql_store_result(&m_sqlconnect);
		//cout<<"(k,";
		while (row = mysql_fetch_row(m_res))
		{
			if (row != NULL)
			{
				cout << "(k,";
 				cout << row[1] << ")" << endl;
                freeconnect();
				Token[n1].t1 = 'k';
				Token[n1].t2 = int(atof(row[1]));
				n1++;
				return true;
			}
		}
		freeconnect();
		return false;
	}
}
int state_change(int state, char ch)//识别器，自动机描述 这个没改
{
	if ((ch == ' ') || (ch == '\t') || (ch == '\n'))
		return 0;
	else if (weatherletter(ch) == 1)
	{
		if (state == 1)
			return 2;
		if (state == 2)
			return 2;
		if (state == 6)
			return 7;
		if (state == 9)
			return 10;
		if (state == 10)
			return 10;
		if (state == 12)  //界符与字母相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 2;
		}
		else
			return -1;
	}
	else if (weatherinteger(ch) == 1)
	{
		if (state == 1)
			return 3;
		if (state == 3)
			return 3;
		if (state == 4)
			return 5;
		if (state == 5)
			return 5;
		if (state == 12)
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 3;
		}
		else
			return -1;
	}
	else if (ch == '.')
	{
		if (state == 3)
			return 4;
		else
			return -1;
	}
	else if (ch == '\'')
	{
		if (state == 1)
			return 6;
		if (state == 12) //界符和单引号相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 6;
		}
		if (state == 7)  //后面的单引号状态
			return 8;
		else
			return -1;
	}
	else if (ch == '\"')  //双引号处理
	{
		if (state == 1)
			return 9;
		if (state == 12)
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 9;
		}
		if (state == 10)
			return 11;
		else
			return -1;
	}
	else if (ch == '=' || ch == '>' || ch == '<' || ch == '=' || ch == '+' || ch == ':'
		|| ch == '-' || ch == '*' || ch == '/' || ch == ',' || ch == ';' || ch == '(' || ch == ')' || ch == '[' || ch == ']')                    //判断是否为界符
	{
		if (state == 1)
			return 12;
		if (state == 2)
		{
			state_to_code(state_before, token);//标识符或者关键字与界符相连的情况
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 3)//常数(正整数)与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 5)//常数（小数）与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 8)//字符与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 11)//字符串与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 12)     //双目界符和界符后加界符的情况
		{
			if (((i == 1) && (ch == '=')) && ((token[0] == '>') ||
				(token[0] == '<') || (token[0] == '=')))
				return 12;
			else    //不是双目界符
			{
				state_to_code(state_before, token);
				i = 0;
				memset(token, 0, 10); //将数组token开始的十个字节置零
				return 12;
			}
		}
		else
			return -1;
	}
	else
		cout << "No such char!" << endl;
}//这里没有变
void state_to_code(int state_before, char* token)   //词法分析器
{
	int n = 0, flagp = 0;
	code1 = 0;
	code2 = 0;
	//printf("%s\n",token);
	switch (state_before)//少个括号
	{
	case 2:
	{
		if (Whetherkeyword(token))
		{
			code1 = 3;
		}
		if (code1 == 0)		//不是关键字，是标识符
		{
			string sql3 = "SELECT * FROM imooc.username WHERE name = ";
			string sql1 = "\'";
			string sql2 = "\'";
			string sql4 = ";";
			string sql = sql3 + sql2 + token + sql1 + sql4;
			connect();
			if (!(mysql_query(&m_sqlconnect, sql.c_str())))
			{
				MYSQL_ROW row;
				m_res = mysql_store_result(&m_sqlconnect);
				row = mysql_fetch_row(m_res);
				freeconnect();
				if (row == NULL)//查找不到
				{
					connect();
					string sql7 = "INSERT INTO imooc.username (name,id) VALUES ('";
					string sql6 = "','";
					string sql5 = "')";
					string tem = to_string(namenumber);
					string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
					mysql_query(&m_sqlconnect, sql4.c_str());
					//freeconnect();
					cout << "(i," << namenumber << ")" << endl;
					Token[n1].t1 = 'i';
					Token[n1].t2 = namenumber;//这里要改一下
					namenumber++;
					n1++;
				}
				else//这个就是找到了
				{
					MYSQL_ROW row1;
					connect();
					if (!mysql_query(&m_sqlconnect, sql.c_str()))
					{
						m_res = mysql_store_result(&m_sqlconnect);
						row1 = mysql_fetch_row(m_res);
						if (row1!=NULL)
						{
							cout << "(i," << row1[1] << ")" << endl;
							Token[n1].t1 = 'i';
							Token[n1].t2 = int(atof(row1[1]));
							n1++;
						}
						else
						{
							cout << "error" << endl;
							n1++;
						}
					}
					else
						cout << mysql_error(&m_sqlconnect);
				}
			}
			else
			{
				cout << mysql_error(&m_sqlconnect);
				freeconnect();
			}
		}
		break;
	}
	case 3:
	{
		string sql3 = "SELECT * FROM imooc.constnumber WHERE const = ";
		string sql1 = "\'";
		string sql2 = "\'";
		string sql4 = ";";
		string sql = sql3 + sql2 + token + sql1 + sql4;
		connect();
		if (!(mysql_query(&m_sqlconnect, sql.c_str())))
		{
			MYSQL_ROW row;
			m_res = mysql_store_result(&m_sqlconnect);
			row = mysql_fetch_row(m_res);
			freeconnect();
			if (row == NULL)//查找不到
			{
				connect();
				string sql7 = "INSERT INTO imooc.constnumber (const,id) VALUES ('";
				string sql6 = "','";
				string sql5 = "')";
				string tem = to_string(constnumber);
				string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
				mysql_query(&m_sqlconnect, sql4.c_str());
				//freeconnect();
				cout << "(c," << constnumber << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 = constnumber;//这里要改一下
				constnumber++;
				n1++;
			}
			else//这个就是找到了
			{
				cout << "(c," << row[1] << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 = int(atof(row[1]));
				n1++;
			}
		}
		break;
	}
	case 5:
	{
		string sql3 = "SELECT * FROM imooc.constnumber WHERE const = ";
		string sql1 = "\'";
		string sql2 = "\'";
		string sql4 = ";";
		string sql = sql3 + sql2 + token + sql1 + sql4;
		connect();
		if (!(mysql_query(&m_sqlconnect, sql.c_str())))
		{
			MYSQL_ROW row;
			m_res = mysql_store_result(&m_sqlconnect);
			row = mysql_fetch_row(m_res);
			freeconnect();
			if (row == NULL)//查找不到
			{
				connect();
				string sql7 = "INSERT INTO imooc.constnumber (const,id) VALUES ('";
				string sql6 = "','";
				string sql5 = "')";
				string tem = to_string(constnumber);
				string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
				mysql_query(&m_sqlconnect, sql4.c_str());
				//freeconnect();
				cout << "(c," << constnumber << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 = constnumber;//这里要改一下
				n1++;
				constnumber++;
			}
			else//这个就是找到了
			{
				cout << "(c," << row[1] << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 =int(atof(row[1]));
				n1++;
			}
		}
		break;
	}
	case 8:
	{
		string sql3 = "SELECT * FROM imooc.chname WHERE charname = ";
		string sql1 = "\'";
		string sql2 = "\'";
		string sql4 = ";";
		string sql = sql3 + sql2 + token + sql1 + sql4;
		connect();
		if (!(mysql_query(&m_sqlconnect, sql.c_str())))
		{
			MYSQL_ROW row;
			m_res = mysql_store_result(&m_sqlconnect);
			row = mysql_fetch_row(m_res);
			freeconnect();
			if (row == NULL)//查找不到
			{
				connect();
				string sql7 = "INSERT INTO imooc.chname (charname,id) VALUES ('";
				string sql6 = "','";
				string sql5 = "')";
				string tem = to_string(charnumber);
				string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
				mysql_query(&m_sqlconnect, sql4.c_str());
				//freeconnect();
				cout << "(i," << charnumber << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 = charnumber;//这里要改一下
				n1++;
				charnumber++;
			}
			else//这个就是找到了
			{
				cout << "(cht," << row[1] << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 =int(atof(row[1]));
				n1++;
			}
		}
		break;
	}
	case 11:
	{
		string sql3 = "SELECT * FROM imooc.sname WHERE stringname = ";
		string sql1 = "\'";
		string sql2 = "\'";
		string sql4 = ";";
		string sql = sql3 + sql2 + token + sql1 + sql4;
		connect();
		if (!(mysql_query(&m_sqlconnect, sql.c_str())))
		{
			MYSQL_ROW row;
			m_res = mysql_store_result(&m_sqlconnect);
			row = mysql_fetch_row(m_res);
			freeconnect();
			if (row == NULL)//查找不到
			{
				connect();
				string sql7 = "INSERT INTO imooc.sname (stringname,id) VALUES ('";
				string sql6 = "','";
				string sql5 = "')";
				string tem = to_string(stringnumber);
				string sql4 = sql7 + token + sql6 + tem+ sql5 + ";";//这里要改一下
				mysql_query(&m_sqlconnect, sql4.c_str());
				//freeconnect()
				cout << "(st," << stringnumber << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 = stringnumber;//这里要改一下
				n1++;
				stringnumber++;
			}
			else//这个就是找到了
			{
				cout << "(st," << row[1] << ")" << endl;
				Token[n1].t1 = 'i';
				Token[n1].t2 =int(atof(row[1]));
				n1++;
			}
		}
		break;
	}
	case 12:
	{
		if (Whethersp(token))
		{
		}
		break;
	}
	default:
		printf("Sorry it's going wrong!");
	}
}




int weatherletter(char c) {	//判断字母
	if (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')))
		return 1;
	else
		return 0;
}

int weatherinteger(char c) {		//判断数字

	if (c >= '0' && c <= '9')
		return 1;
	else
		return 0;
}

T token1;//存放序列的第一个值
int flag = 1;//编译成功的标志

void error(string err)
{
	flag = 0;
	cout << "ERROR!" + err << endl;
}
T getToken()
{
	token1.t1 = Token[n2].t1;
	token1.t2 = Token[n2].t2;
	n2++;
	return token1;
}
void PROGRAM() //程序开始子程序
{
	token1 = getToken();
	if (token1.t1 != 'k' || token1.t2 != 5)
		error("PROGRAM");
	else
	{
		token1 = getToken();
		if (token1.t1 != 'i')
			error("PROGRAM");
		else
		{
			token1 = getToken();
			SUB_PROGRAM();
		}
	}
}
void VARIBLE() //变量声明子程序
{
	if (token1.t1 != 'k' || token1.t2 != 10)
		error("VARIBLE,var not declined!");
	else
	{
		token1 = getToken();
		ID_SEQUENCE();
		if (token1.t1 != 'p' || token1.t2 != 16)
			error("VARIBLE");
		else
		{
			token1 = getToken();
			TYPE();
			if (token1.t1 != 'p' || token1.t2 != 11)
				error("VARIBLE");
			else
				token1 = getToken();
		}
	}
}
void ID_SEQUENCE() //变量名
{
	if (token1.t1 != 'i')
		error("ID_SEQUENCE");
	else
	{
		token1 = getToken();
	A: if (token1.t1 != 'p' || token1.t2 != 10)
		return;
	   else
	{
		token1 = getToken();
		if (token1.t1 != 'i')
			error("ID_SEQUENCE");
		else
		{
			token1 = getToken();
			goto A;
		}

	}
	}
}
void TYPE()  //类型子程序
{
	if (token1.t1 != 'k')
		error("TYPE");
	else
	{
		if (token1.t2 == 1 || token1.t2 == 2 || token1.t2 == 3 ||
			token1.t2 == 4)
			token1 = getToken();
		else
			error("TYPE");
	}
}
void EVA_SENTENCE()  //赋值语句
{
	if (token1.t1 != 'i')
		return;
	else
	{
		token1 = getToken();
		if (token1.t1 != 'p' || token1.t2 != 3)
			error("EVA_SENTENCE2");
		else
		{
			token1 = getToken();
			EXPRESSION();
		}
	}
}
void SUB_PROGRAM()  //子程序
{
	VARIBLE();
	COM_SENTENCE();
}
void COM_SENTENCE()   //复合语句子程序
{
	if (token1.t1 != 'k' || token1.t2 != 8)
		error("COM_SENTENCE1");
	else
	{
		token1 = getToken();
		if (token1.t1 == 'i')
		{
			token1 = getToken();
			SEN_SEQUENCE();
		}
		else if (token1.t1 == 'k' && token1.t2 == 6)
		{
			token1 = getToken();
			IF_SENTENCE();
		}
		else if (token1.t1 == 'k' && token1.t2 == 11)
		{
			token1 = getToken();
			WHILE_SENTENCE();
		}
		else
			error("COM_SENTENCE");
	}
}
void SEN_SEQUENCE() //赋值循环语句
{
	EVA_SENTENCE();
B:if (token1.t1 != 'p' || token1.t2 != 11)
	return;
  else
{
	token1 = getToken();
	EVA_SENTENCE();
	goto B;
}
}
void WHILE_SENTENCE()  //while循环语句
{
	if (token1.t1 != 'p' || token1.t2 != 12)
		error("WHILE_SENTENCE");
	else
	{
		token1 = getToken();
		BOOL_EXPRESSION();
		if (token1.t1 != 'p' || token1.t2 != 13)
			error("WHILE_SENTENCE");
		else
		{
			token1 = getToken();
			COM_SENTENCE();
		}
	}
}
void BOOL_EXPRESSION() //bool表达式
{
	EXP();
	if (token1.t1 != 'p' || token1.t2 != 17)
		return;
	else
	{
		token1 = getToken();
		if (token1.t1 != 'p' || token1.t2 != 17)
			error("BOOL_EXPRESSION");
		else
		{
			token1 = getToken();
			BOOL_EXPRESSION();
		}
	}
}
void EXP() //bool表达式分支
{
	EXP1();
	if (token1.t1 != 'p' || token1.t2 != 18)
		return;
	else
	{
		token1 = getToken();
		if (token1.t1 != 'p' || token1.t2 != 18)
			error("EXP");
		else
		{
			token1 = getToken();
			EXP();
		}
	}
}
void EXP1() //bool表达式分支
{
	if (token1.t1 == 'i')
	{
		token1 = getToken();
		return;
	}
	else
		EXPRESSION();
}
void IF_SENTENCE() //if语句子程序
{
	if (token1.t1 != 'p' || token1.t2 != 12)
		error("IF_SENTENCE");
	else
	{
		token1 = getToken();
		BOOL_EXPRESSION();
		if (token1.t1 != 'p' || token1.t2 != 13)
			error("IF_SENTENCE");
		else
		{
			token1 = getToken();
			COM_SENTENCE();
			IF1();
		}
	}
}
void IF1() //else语句
{
	if (token1.t1 != 'k' || token1.t2 != 7)
		return;
	else
	{
		token1 = getToken();
		COM_SENTENCE();
	}
}
void EXPRESSION() //表达式
{
	TERM();
	if (token1.t1 != 'p' || token1.t2 != 6)
		return;
	else
	{
		token1 = getToken();
		EXPRESSION();
	}
}
void TERM() //表达式分支
{
	FACTOR();
	if (token1.t1 != 'p' || token1.t2 != 8)
		return;
	else
	{
		token1 = getToken();
		TERM();
	}
}
void FACTOR() //表达式分支
{
	if (token1.t1 != 'p' || token1.t2 != 12)
	{
		if (token1.t1 != 'i')
		{
			if (token1.t1 != 'c')
				error("FACTOR");
			else
			{
				token1 = getToken();
				return;
			}
		}
		else
		{
			token1 = getToken();
			return;
		}
	}
	else
	{
		token1 = getToken();
		EXPRESSION();
		if (token1.t1 != 'p' || token1.t2 != 13)
			error("FACTOR");
		else
		{
			token1 = getToken();
			return;
		}
	}
}
int main()
{
	char inFile[40];
	state = 1;
	cin >> inFile;
	if ((fp = fopen(inFile, "r")) == NULL)
	{
		printf("NOT open file!\n");
		exit(1);
	}
	while ((ch = fgetc(fp)) != '#')
	{
		state_before = state;
		state = state_change(state, ch);
		if (state == -1)
		{
			printf(" Error! \n");
		}
		else if (state != 0)
		{
			token[i++] = ch;
		}
		else
		{
			if (state_before != 1)
			{
				state_to_code(state_before, token);
			}
			memset(token, 0, 10);
			i = 0;
			state = 1;
		}
		if (ch == '#')
		{
			Token[n1].t1 = '#';
			n1++;
			printf("%c\n", Token[n1 - 1].t1);
		}
	}
	PROGRAM();
	if (flag == 1)
		cout << "Success!" << endl;
	else
		cout << "Fail!" << endl;
	return 0;
}*/
#define _CRT_SECURE_NO_WARNINGS
#include <iostream>
#include <string>
#include<fstream>
#include<windows.h>
#include <vector>
#include"mysql.h";
using namespace std;
struct Sign_item  //符号表主表项
{
	string name;//单词标识符
	int type = -1; //TYPEL中的偏移量,-1表示没有类型
	char cat = 'a'; //种类编码：f,c,t,d（域名）,v,其中a表示初值，不知属于哪种类型
	int addr = -1; //常数,结构,数组,函数时为各表中的偏移量;当为变量或参数时为活动记录中的偏移量,
				//-1表示待填状态
};
struct Type_item//类型表项
{
	char tcode;//类型代码:i,f,b,c,a
	int tpoint = -1;//AINEL或RINFL中的偏移量
};
struct Ainel_item//数组表项
{
	int low;//数组的下界
	int up;//数组的上界
	int ctp;//数组元素的类型，type_item中的偏移量
	int clen;//成分类型的长度
};
struct Rinfl_item//结构表项
{
	string id;//结构表域名
	int off;//当前结构首址的地址
	int tp;//类型，TYPEL中的偏移量
};
struct Function_item
{
	int level;//嵌套层次号
	int off = -1;//区距
	int numf;//参数个数
	string entry = "0";//入口地址
	int param = -1;//参数表
};
struct QT_item//四元式结构体
{
	string w;//算符
	string o1;//运算对象1
	string o2;//运算对象2
	string t;//结果
};

MYSQL m_sqlconnect;
MYSQL_RES* m_res;
struct T   //token项定义
{
	char t1;
	int t2;
};
int c2;     //用于语法分析中等于线性表中t2
char c1;    //用于语法分析中等于线性表中t1
int namenumber = 0;
int constnumber = 0;
vector<T> Token;     //线性表，存储token序列
FILE* fp;
char token[10];
char ch;
int i = 0;          //token下标
int state;			//存放状态标记
int code1;       //token类别码,1->IT,3->CT,3->KT,4->CHT,5->ST,6->PT
int code2;       //表内序号
int state_before;
int num;
int numi = 0, numc = 0, numch = 0, nums = 0;

vector<Sign_item> Sign_table; //符号表主表
vector<Type_item> Type_table;  //类型表
vector<Ainel_item> Ainel;   //数组表
vector<Rinfl_item> Rinfl;    //结构表
vector<Function_item> Function_table;  //函数表
vector<string> Const_table;   //常数表
vector<int> Length_table;     //长度表
vector<char> Char_table;     //字符表
vector<string> String_table; //字符串表
vector<QT_item> QT; //四元式序列
vector<string> SEM;//四元式 语义栈
int state_change(int state, char ch);
int state_to_code(int state_before, char* token);
int weatherinteger(char c);;
void ID_SEQUENCE();
void SUB_PROGRAM();
void TYPE();
void EXPRESSION();
void COM_SENTENCE();
void SEN_SEQUENCE();
void EVA_SENTENCE();
void BOOL_EXPRESSION();
void IF_SENTENCE();
void WHILE_SENTENCE();
void ITEM_EXPRESSION();
void VARIBLE();
void EXP();
void TERM();
void FACTOR();
void IF1();
void EXP1();

T token1;//存放某一个序列
int flag = 1;//编译成功的标志

int num_v = 0, num_i = 0;  //多个变量进行填表时所需的数据（几个变量和到哪结束）

int qt1 = 1;//四元式序列中间结果t的下标

int n2 = 0; //存放序列表的下标

int False = 0;//错误判断
void Init()   //初始化，把最基本的数据类型先存进去
{
	Type_item t;
	t.tcode = 'i';
	Type_table.push_back(t);
	t.tcode = 'c';
	Type_table.push_back(t);
	t.tcode = 'b';
	Type_table.push_back(t);
	t.tcode = 'f';
	Type_table.push_back(t);
}
void error(string err)
{
	flag = 0;
	cout << "ERROR!" + err << endl;
}
T getToken()
{
	
	if (n2 > Token.size() - 1)
		return token1;
	token1.t1 = Token[n2].t1;
	token1.t2 = Token[n2].t2;
	n2++;
	return token1;
}
void PROGRAM() //程序开始子程序
{
	token1 = getToken();
	if (token1.t1 != 'k' || token1.t2 != 5)
		error("PROGRAM");
	else
	{
		token1 = getToken();
		if (token1.t1 != 'i')
			error("PROGRAM");
		else
		{
			cout << token1.t1;
			cout << token1.t2;
			Function_item f;
			f.level = 1;
			f.numf = 0;
			Function_table.push_back(f);
			Sign_table[token1.t2].cat = 'f';
			Sign_table[token1.t2].addr = Function_table.size() - 1;
			token1 = getToken();
			SUB_PROGRAM();
		}
	}
}
void SUB_PROGRAM()  //子程序
{
	VARIBLE();
	COM_SENTENCE();
}
void VARIBLE() //变量声明子程序
{
	while (token1.t1 == 'k' && token1.t2 == 10 || token1.t1 == 'k' && token1.t2 == 12)
	{         //判断var或者arrary
		if (token1.t1 == 'k' && token1.t2 == 10) //var
		{
			token1 = getToken();
			ID_SEQUENCE();
			if (token1.t1 != 'p' || token1.t2 != 16)  //判断冒号
				error("VARIBLE");
			else
			{
				token1 = getToken();
				TYPE();
				if (token1.t1 != 'p' || token1.t2 != 11) //分号
					error("VARIBLE1");
				else
					token1 = getToken();
			}
		}
		else  //arrary
		{
			token1 = getToken();
			TYPE();
			ID_SEQUENCE();
			if (token1.t1 != 'p' || token1.t2 != 14)  //  [
				error("expect [ !");
			else
			{
				token1 = getToken();
				EXPRESSION();
				string s;   //判断[]里的表达式结果是否是整形
				int k = -1;
				s = SEM[SEM.size() - 1];
				SEM.pop_back();
				for (int i = 0; i < Sign_table.size(); i++)
				{
					if (Sign_table[i].name == s)
					{
						k = Sign_table[i].type;
						break;
					}
				}
				if (k != 0)
					error("[] near type error!");//不是整形报错
				if (token1.t1 != 'p' || token1.t2 != 15)  //  ]
					error("expect ] !");
				else
				{
					token1 = getToken();
					if (token1.t1 != 'p' || token1.t2 != 11) //分号
						error("expect ; !");
					else
						token1 = getToken();
				}
			}
		}
	}
}
void ID_SEQUENCE() //变量定义时 变量名
{
	if (token1.t1 != 'i')
		error("ID_SEQUENCE");
	else
	{
		int num = 0;    //判断变量是否重定义
		for (int i = 0; i < n2 + 1; i++)
		{
			if (token1.t1 == Token[i].t1 && token1.t2 == Token[i].t2)
				num++;
		}
		if (num > 1)
		{
			cout << "Double defined!" << endl;
			False = 1;
		}         //判断变量是否重定义
		Sign_table[token1.t2].cat = 'v';
		num_v++;
		num_i = token1.t2;
		token1 = getToken();
		while (token1.t1 == 'p' && token1.t2 == 10)  //判断是否是逗号
		{
			token1 = getToken();
			if (token1.t1 != 'i')
				error("ID_SEQUENCE");
			else
			{
				int num = 0;    //判断变量是否重定义
				for (int i = 0; i < n2 + 1; i++)
				{
					if (token1.t1 == Token[i].t1 && token1.t2 == Token[i].t2)
						num++;
				}
				if (num > 1)
				{
					cout << "Double defined!" << endl;
					False = 1;
				}         //判断变量是否重定义
				Sign_table[token1.t2].cat = 'v';
				num_v++;
				num_i = token1.t2;
				token1 = getToken();
			}
		}
	}
}
void TYPE()  //类型子程序
{
	if (token1.t1 != 'k')
		error("TYPE");
	else
	{
		switch (token1.t2)
		{
		case 1: //int
			for (int i = 0; i < num_v; i++)
				Sign_table[num_i - i].type = 0;
			num_i = 0;
			num_v = 0;
			break;
		case 2:  //float
			for (int i = 0; i < num_v; i++)
				Sign_table[num_i - i].type = 3;
			num_i = 0;
			num_v = 0;
			break;
		case 3:  //bool
			for (int i = 0; i < num_v; i++)
				Sign_table[num_i - i].type = 2;
			num_i = 0;
			num_v = 0;
			break;
		case 4:  //char
			for (int i = 0; i < num_v; i++)
				Sign_table[num_i - i].type = 1;
			num_i = 0;
			num_v = 0;
			break;
		default:error("TYPE");
		}
		token1 = getToken();
	}
}

void COM_SENTENCE()   //复合语句子程序
{
	if (token1.t1 != 'k' || token1.t2 != 8)  //begin
		error("COM_SENTENCE1");
	else
	{
		token1 = getToken();
		while (token1.t1 == 'i' || token1.t1 == 'k' && token1.t2 == 6
			|| token1.t1 == 'k' && token1.t2 == 11)
		{
			if (token1.t1 == 'i')  //标识符
			{
				//token1=getToken();
				SEN_SEQUENCE();
			}
			else if (token1.t1 == 'k' && token1.t2 == 6)  //if
			{
				token1 = getToken();
				IF_SENTENCE();
			}
			else if (token1.t1 == 'k' && token1.t2 == 11) //while
			{
				token1 = getToken();
				WHILE_SENTENCE();
			}
			else
				error("COM_SENTENCE");
		}
	}
	if (token1.t1 != 'k' || token1.t2 != 9)  //end
		error("1expect \"end\"!");
	else
	{
		token1 = getToken();
		return;
	}
}
void SEN_SEQUENCE() //赋值循环语句
{
	EVA_SENTENCE();
	//token1 = getToken();
	while (token1.t1 == 'p' && token1.t2 == 11) //p11为分号
	{
		token1 = getToken();
		EVA_SENTENCE();
	}
}
void EVA_SENTENCE()  //赋值语句
{
	if (token1.t1 != 'i')
		return;
	else
	{
		SEM.push_back(Sign_table[token1.t2].name);
		token1 = getToken();
		if (token1.t1 != 'p' || token1.t2 != 3)  //判断等号
			error("EVA_SENTENCE2");
		else
		{
			token1 = getToken();
			EXPRESSION();
			QT_item q;    //语义动作=
			q.w = "=";
			q.o1 = SEM[SEM.size() - 1];
			SEM.pop_back();
			q.o2 = "0";
			q.t = SEM[SEM.size() - 1];
			SEM.pop_back();
			QT.push_back(q);
			//判断运算对象类型是否匹配
			int k = -1, l = -1;
			for (int i = 0; i < Sign_table.size(); i++)
			{
				if (Sign_table[i].name == q.o1)
					k = Sign_table[i].type;
				if (Sign_table[i].name == q.t)
					l = Sign_table[i].type;
			}
			if (k != l)
			{
				cout << "type is different!" << endl;
				False = 1;
			}
			//判断运算对象类型是否匹配  */
		}
	}
}
void WHILE_SENTENCE()  //while循环语句
{
	QT_item q;    //语义动作while
	q.w = "wh";
	q.o1 = "0";
	q.o2 = "0";
	q.t = "0";
	QT.push_back(q);
	if (token1.t1 != 'p' || token1.t2 != 12)  //p12=(
		error("WHILE_SENTENCE");
	else
	{
		token1 = getToken();
		BOOL_EXPRESSION();
		if (token1.t1 != 'p' || token1.t2 != 13)
			error("WHILE_SENTENCE");
		else
		{
			QT_item q;    //语义动作do
			q.w = "do";
			q.o1 = SEM[SEM.size() - 1];
			SEM.pop_back();
			q.o2 = "0";
			q.t = "0";
			QT.push_back(q);
			token1 = getToken();
			COM_SENTENCE();

			q.w = "we";        //语义动作we
			q.o1 = "0";
			q.o2 = "0";
	
			for (int i = QT.size() - 2; i >= 0; i--)  //we地址
			{
				if (QT[i].w == "wh" && QT[i].t == "0")
				{
					string str;
					char str1[100];
					sprintf(str1, "%d", i + 1);
					str = str1;
					q.t = str;
					break;
				}
			}
			QT.push_back(q);
	
			for (int i = QT.size() - 2; i >= 0; i--)  //do地址回填
			{
				if (QT[i].w == "do" && QT[i].t == "0")
				{
					string str;
					char str1[100];
					sprintf(str1, "%d", QT.size());
					str = str1;
					QT[i].t = str;
					break;
				}
			}
		}
	}
}
void BOOL_EXPRESSION() //bool表达式
{
	EXP();
	if (token1.t1 != 'p' || token1.t2 != 17)  //p17=&&
		return;
	else
	{
		token1 = getToken();
		BOOL_EXPRESSION();
	}
}
void EXP() //bool表达式分支
{
	ITEM_EXPRESSION();
	if (token1.t1 != 'p' || token1.t2 != 18) //p18=||
		return;
	else
	{
		token1 = getToken();
		EXP();
	}
}
void ITEM_EXPRESSION()
{
	EXPRESSION();
	if (token1.t1 == 'p' && token1.t2 == 4)//p4为>
	{
		token1 = getToken();
		EXPRESSION();
		QT_item q;    //语义动作 >
		q.w = ">";
		q.o2 = SEM[SEM.size() - 1];
		SEM.pop_back();
		q.o1 = SEM[SEM.size() - 1];
		SEM.pop_back();
		char str1[100];
		sprintf(str1, "%d", qt1);
		string str = "t";
		str = str + str1;
		qt1++;
		q.t = str;
		QT.push_back(q);
		SEM.push_back(str);
		//判断运算对象类型是否匹配
		int k = -1, l = -1;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
			{
				k = Sign_table[i].type;
			}
			if (Sign_table[i].name == q.o2)
			{
				l = Sign_table[i].type;
			}
		}
		if (k != l)
		{
			cout << ">  type is different!" << endl;
			False = 1;
		}
		//判断运算对象类型是否匹配*/
		//临时变量填入符号表中
		Sign_item it;
		it.name = str;
		it.type = 2;
		it.cat = 'v';
		Sign_table.push_back(it);
		//临时变量填入符号表中
	}
	else if (token1.t1 == 'p' && token1.t2 == 5) //p5为<
	{
		token1 = getToken();
		EXPRESSION();
		QT_item q;    //语义动作<
		q.w = "<";
		q.o2 = SEM[SEM.size() - 1];
		SEM.pop_back();
		q.o1 = SEM[SEM.size() - 1];
		SEM.pop_back();
		char str1[100];
		sprintf(str1, "%d", qt1);
		string str = "t";
		str = str + str1;
		qt1++;
		q.t = str;
		QT.push_back(q);
		SEM.push_back(str);
		//判断运算对象类型是否匹配
		int k = -1, l = -1;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
			{
				k = Sign_table[i].type;
			}
			if (Sign_table[i].name == q.o2)
			{
				l = Sign_table[i].type;
			}
		}
		if (k != l)
		{
			cout << "<  type is different!" << endl;
			False = 1;
		}
		//判断运算对象类型是否匹配*/
		//临时变量填入符号表中
		Sign_item it;
		it.name = str;
		it.type = 2;
		it.cat = 'v';
		Sign_table.push_back(it);
		//临时变量填入符号表中
	}
	else if (token1.t1 == 'p' && token1.t2 == 2) //p2 为等号
	{
		token1 = getToken();
		EXPRESSION();
		QT_item q;    //语义动作==
		q.w = "==";
		q.o2 = SEM[SEM.size() - 1];
		SEM.pop_back();
		q.o1 = SEM[SEM.size() - 1];
		SEM.pop_back();
		char str1[100];
		sprintf(str1, "%d", qt1);
		string str = "t";
		str = str + str1;
		qt1++;
		q.t = str;
		QT.push_back(q);
		SEM.push_back(str);
		//判断运算对象类型是否匹配
		int k = -1, l = -1;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
			{
				k = Sign_table[i].type;
			}
			if (Sign_table[i].name == q.o2)
			{
				l = Sign_table[i].type;
			}
		}
		if (k != l)
		{
			cout << "==  type is different!" << endl;
			False = 1;
		}
		//判断运算对象类型是否匹配*/
		//临时变量填入符号表中
		Sign_item it;
		it.name = str;
		it.type = 2;
		it.cat = 'v';
		Sign_table.push_back(it);
		//临时变量填入符号表中
	}
	else
		error("Expect < > ==!");
}
void IF_SENTENCE() //if语句子程序
{
	if (token1.t1 != 'p' || token1.t2 != 12)  //p12=(
		error("IF_SENTENCE1");
	else
	{
		token1 = getToken();
		BOOL_EXPRESSION();
		if (token1.t1 != 'p' || token1.t2 != 13) //p13=)
			error("expect \")\"");
		else
		{
			QT_item q;    //语义动作IF(if)
			q.w = "if";
			q.o1 = SEM[SEM.size() - 1];
			SEM.pop_back();
			q.o2 = "0";
			q.t = "0";
			QT.push_back(q);
			token1 = getToken();
			COM_SENTENCE();
			IF1();

			//语义动作IE(ie)   if语句结束
			q.w = "ie";
			q.o1 = "0";
			q.o2 = "0";
			q.t = "0";
			QT.push_back(q);
			int m = 0;  //用来判断循环里if语句有没有执行
			for (int i = QT.size() - 2; i >= 0; i--)  //el地址回填
			{
				if (QT[i].w == "el" && QT[i].t == "0")
				{
					m = 1;
					string str;
					char str1[100];
					sprintf(str1, "%d", QT.size() - 1);
					str = str1;
					QT[i].t = str;
					break;
				}
			}
			if (m == 0)
			{
				for (int i = QT.size() - 2; i >= 0; i--)  //if地址回填
				{
					if (QT[i].w == "if" && QT[i].t == "0")
					{
						string str;
						char str1[100];
						sprintf(str1, "%d", QT.size() - 1);
						str = str1;
						QT[i].t = str;
						break;
					}
				}
			}
	
		}
	}
}
void IF1() //else语句
{
	if (token1.t1 != 'k' || token1.t2 != 7) //k7=else
		return;
	else
	{
		QT_item q;    //语义动作EL(el)
		q.w = "el";
		q.o1 = "0";
		q.o2 = "0";
		q.t = "0";
		QT.push_back(q);

		for (int i = QT.size() - 2; i >= 0; i--)  //if地址回填
		{
			if (QT[i].w == "if" && QT[i].t == "0")
			{
				string str;
				char str1[100];
				sprintf(str1, "%d", QT.size());
				str = str1;
				QT[i].t = str;
				break;
			}
		}
		token1 = getToken();
		COM_SENTENCE();
	}
}
void EXPRESSION() //表达式
{
	TERM();
	if (token1.t1 != 'p' || token1.t2 != 6) //判断加号
		return;
	else
	{
		token1 = getToken();
		EXPRESSION();
		QT_item q;    //语义动作+
		q.w = "+";
		q.o2 = SEM[SEM.size() - 1];
		SEM.pop_back();
		q.o1 = SEM[SEM.size() - 1];
		SEM.pop_back();
		char str1[100];
		sprintf(str1, "%d", qt1);
		string str = "t";
		str = str + str1;
		qt1++;
		q.t = str;
		QT.push_back(q);
		SEM.push_back(str);
		//判断运算对象类型是否匹配
		int k = -1, l = -1;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
			{
				k = Sign_table[i].type;
			}
			if (Sign_table[i].name == q.o2)
			{
				l = Sign_table[i].type;
			}
		}
		if (k != l)
		{
			cout << "type is different!" << endl;
			False = 1;
		}
		//判断运算对象类型是否匹配*/
		//临时变量填入符号表中
		Sign_item it;
		it.name = str;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
			{
				it.type = Sign_table[i].type;
				break;
			}
		}
		it.cat = 'v';
		Sign_table.push_back(it);

	}
}
void TERM() //表达式分支
{
	FACTOR();
	if (token1.t1 != 'p' || token1.t2 != 8) //p8=*
		return;
	else
	{
		token1 = getToken();
		TERM();
		QT_item q;    //语义动作*
		q.w = "*";
		q.o2 = SEM[SEM.size() - 1];
		SEM.pop_back();
		q.o1 = SEM[SEM.size() - 1];
		SEM.pop_back();
		char str1[100];
		sprintf(str1, "%d", qt1);
		string str = "t";
		str = str + str1;
		qt1++;
		q.t = str;
		QT.push_back(q);
		SEM.push_back(str);
		//临时变量填入符号表中
		Sign_item it;
		it.name = str;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
			{
				it.type = Sign_table[i].type;
				break;
			}
		}
		it.cat = 'v';
		Sign_table.push_back(it);
		//判断运算对象类型是否匹配
		int k = -1, l = -1;
		for (int i = 0; i < Sign_table.size(); i++)
		{
			if (Sign_table[i].name == q.o1)
				k = Sign_table[i].type;
			if (Sign_table[i].name == q.o2)
				l = Sign_table[i].type;
		}
		if (k != l)
		{
			cout << "type is different!" << endl;
			False = 1;
		}
		//判断运算对象类型是否匹配
	}
}
void FACTOR() //表达式分支
{
	if (token1.t1 != 'p' || token1.t2 != 12) //左括号
	{
		if (token1.t1 != 'i')
		{
			if (token1.t1 != 'c') //常数
				error("FACTOR");
			else
			{
				SEM.push_back(Sign_table[token1.t2].name);
				token1 = getToken();
				return;
			}
		}
		else  //标识符
		{
			SEM.push_back(Sign_table[token1.t2].name);
			token1 = getToken();
			return;
		}
	}
	else  //是左括号后的判断
	{
		token1 = getToken();
		EXPRESSION();
		if (token1.t1 != 'p' || token1.t2 != 13)
			error("FACTOR");
		else
		{
			token1 = getToken();
			return;
		}
	}
}
bool connect()//建立连接
{
	mysql_init(&m_sqlconnect);
	if (!mysql_real_connect(&m_sqlconnect, "localhost", "root", "123456", "mysql", 3306, NULL, 0))
	{
		cout << "Error connecting to database" << endl;
		return false;
	}
	else
	{
		//cout << "connected" << endl;
		return true;
	}
}
void freeconnect()//释放资源
{
	mysql_close(&m_sqlconnect);
	mysql_free_result(m_res);
}

bool Whetherkeyword(char* word)
{
	connect();
	string sql3 = "SELECT * FROM imooc.keyword WHERE temp =";
	string sql1 = "\"";
	string sql2 = "\"";
	string sql4 = ";";
	string sql = sql3 + sql1 + word + sql2 + sql4;
	//cout << sql<<endl;
	if ((mysql_query(&m_sqlconnect, sql.c_str())) == 0)
	{
		MYSQL_ROW row = NULL;
		m_res = mysql_store_result(&m_sqlconnect);
		//cout<<"(k,";
		while (row = mysql_fetch_row(m_res))
		{
			if (row != NULL)
			{
				cout << "(k,";
				cout << row[1] << ")" << endl;
				T t;
				t.t1 = 'k';
				t.t2 = int(atof(row[1]));
				freeconnect();
				Token.push_back(t);
				return true;
			}
		}
		freeconnect();
		return false;
	}
}int weatherletter(char c) {	//判断字母
	if (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')))
		return 1;
	else
		return 0;
}
int weatherinteger(char c) {		//判断数字

	if (c >= '0' && c <= '9')
		return 1;
	else
		return 0;
}

bool Whethersp(string ch)
{
	connect();
	string sql3 = "SELECT * FROM imooc.delimiter WHERE delimiter = ";
	string sql1 = "\"";
	string sql2 = "\"";
	string sql4 = ";";
	string sql = sql3 + sql2 + ch + sql1 + sql4;
	//cout << sql;
	if ((mysql_query(&m_sqlconnect, sql.c_str())) == 0)
	{
		MYSQL_ROW row=NULL;
		m_res = mysql_store_result(&m_sqlconnect);
		while (row = mysql_fetch_row(m_res))
		{
			if (row != NULL)
			{
				cout << "(p,";
				cout << row[1] << ")" << endl;
				T t;
				t.t1 = 'p';
				t.t2 = int(atof(row[1]));//
				freeconnect();
				Token.push_back(t);
				return true;
			}
		}
		freeconnect();
		return false;
	}
	else
	{
		cout << mysql_error(&m_sqlconnect);
	}
}
int state_change(int state, char ch)//识别器，自动机描述
{
	if ((ch == ' ') || (ch == '\t') || (ch == '\n'))
		return 0;
	else if (weatherletter(ch) == 1)
	{
		if (state == 1)
			return 2;
		if (state == 2)
			return 2;
		if (state == 6)
			return 7;
		if (state == 9)
			return 10;
		if (state == 10)
			return 10;
		if (state == 12)  //界符与字母相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 2;
		}
		else
			return -1;
	}
	else if (weatherinteger(ch) == 1)
	{
		if (state == 1)
			return 3;
		if (state == 3)
			return 3;
		if (state == 4)
			return 5;
		if (state == 5)
			return 5;
		if (state == 12)
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 3;
		}
		else
			return -1;
	}
	else if (ch == '.')
	{
		if (state == 3)
			return 4;
		else
			return -1;
	}
	else if (ch == '\'')
	{
		if (state == 1)
			return 6;
		if (state == 12) //界符和单引号相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 6;
		}
		if (state == 7)  //后面的单引号状态
			return 8;
		else
			return -1;
	}
	else if (ch == '\"')  //双引号处理
	{
		if (state == 1)
			return 9;
		if (state == 12)
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 9;
		}
		if (state == 10)
			return 11;
		else
			return -1;
	}
	else if (ch == '=' || ch == '>' || ch == '<' || ch == '=' || ch == '+' || ch == ':'
		|| ch == '-' || ch == '*' || ch == '/' || ch == ',' || ch == ';' || ch == '(' || ch == ')' || ch == '[' || ch == ']')                    //判断是否为界符
	{
		if (state == 1)
			return 12;
		if (state == 2)
		{
			state_to_code(state_before, token);//标识符或者关键字与界符相连的情况
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 3)//常数(正整数)与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 5)//常数（小数）与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 8)//字符与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 11)//字符串与界符相连的情况
		{
			state_to_code(state_before, token);
			i = 0;
			memset(token, 0, 10); //将数组token开始的十个字节置零
			return 12;
		}
		if (state == 12)     //双目界符和界符后加界符的情况
		{
			if (((i == 1) && (ch == '=')) && ((token[0] == '>') ||
				(token[0] == '<') || (token[0] == '=')))
				return 12;
			else    //不是双目界符
			{
				state_to_code(state_before, token);
				i = 0;
				memset(token, 0, 10); //将数组token开始的十个字节置零
				return 12;
			}
		}
		else
			return -1;
	}
	else
		cout << "No such char!" << endl;
}
int state_to_code(int state_before, char* token)   //词法分析器
{
	int n = 0, flagp = 0;
	code1 = 0;
	code2 = 0;
	switch (state_before)
{
	case 2:
	{
		if (Whetherkeyword(token))
		{
			code1 = 3;
		}
		if (code1 == 0)		//不是关键字，是标识符
		{
			string sql3 = "SELECT * FROM imooc.sign WHERE name = ";
			string sql1 = "\'";
			string sql2 = "\'";
			string sql4 = ";";
			string sql = sql3 + sql2 + token + sql1 + sql4;
			connect();
			if (!(mysql_query(&m_sqlconnect, sql.c_str())))
			{
				MYSQL_ROW row;
				m_res = mysql_store_result(&m_sqlconnect);
				row = mysql_fetch_row(m_res);
				freeconnect();
				if (row == NULL)//查找不到
				{
					connect();
					string sql7 = "INSERT INTO imooc.sign (name,type,cat,addr,id) VALUES ('";
					string sql6 = "','";
					string sql5 = "')";
					string tem = to_string(namenumber);
					//string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
					string sql4 = sql7 + token + sql6 + "-1" + sql6 + "a" + sql6 + "-1" + sql6+tem+sql5 + ";";
					mysql_query(&m_sqlconnect, sql4.c_str());
					//freeconnect();
					cout << "(i," << namenumber << ")" << endl;
					T t;
					t.t1 = 'i';
					t.t2 = namenumber;
					namenumber++;
					Token.push_back(t);
					Sign_item s;
					s.name = token;
					Sign_table.push_back(s);
				}
				else//这个就是找到了
				{
					MYSQL_ROW row1;
					connect();
					if (!mysql_query(&m_sqlconnect, sql.c_str()))
					{
						m_res = mysql_store_result(&m_sqlconnect);
						row1 = mysql_fetch_row(m_res);
						if (row1 != NULL)
						{
							cout << "(i," << row1[4] << ")" << endl;
							T t;
							t.t1 = 'i';
							t.t2 = int(atof(row1[4]));
							Token.push_back(t);
						}
						else
						{
							cout << ERROR << endl;
						}
					}
					else
						cout << mysql_error(&m_sqlconnect);
				}
			}
			else
			{
				cout << mysql_error(&m_sqlconnect);
				freeconnect();
			}
		}
		break;
	}
	case 3://有问题
	{
		string sql3 = "SELECT * FROM imooc.sign WHERE name = ";
		string sql1 = "\'";
		string sql2 = "\'";
		string sql4 = ";";
		string sql = sql3 + sql2 + token + sql1 + sql4;
		connect();
		if (!(mysql_query(&m_sqlconnect, sql.c_str())))
		{
			MYSQL_ROW row;
			m_res = mysql_store_result(&m_sqlconnect);
			row = mysql_fetch_row(m_res);
			freeconnect();
			if (row == NULL)//查找不到
			{
				connect();
				string sql7 = "INSERT INTO imooc.sign (name,type,cat,addr,id) VALUES ('";
				string sql6 = "','";
				string sql5 = "')";
				string tem = to_string(namenumber);
				string sql4 = sql7 + token + sql6 + "0" + sql6 + "c" + sql6 + "-1" +sql6+tem +sql5 + ";";//这里要改一下看一下是从第几个开始的 
				mysql_query(&m_sqlconnect, sql4.c_str());
				//freeconnect();
				cout << "(c," << namenumber << ")" << endl;
				Sign_item s;
				s.name = token;
				s.type = 0;
				s.cat = 'c';
				s.addr = Const_table.size();
				Sign_table.push_back(s);
				T t;
				t.t1 = 'c';
				t.t2 = namenumber;
				Token.push_back(t);
				Const_table.push_back(token);
				namenumber++;
			}
			else//这个就是找到了
			{
				connect();
				MYSQL_ROW row1;
				mysql_query(&m_sqlconnect, sql.c_str());
				m_res = mysql_store_result(&m_sqlconnect);
				row1 = mysql_fetch_row(m_res);
				if (row1 != NULL)
				{
					cout << "(c," << row1[4] << ")" << endl;
					T t;
					t.t1 = 'c';
					t.t2 = int(atof(row1[4]));
					Token.push_back(t);
				}
				else 
				{
					;
				}
			}
		}
		break;
	}
	case 5://常数为小数时 有问题
	{
		string sql3 = "SELECT * FROM imooc.sign WHERE name = ";
		string sql1 = "\'";
		string sql2 = "\'";
		string sql4 = ";";
		string sql = sql3 + sql2 + token + sql1 + sql4;
		connect();
		if (!(mysql_query(&m_sqlconnect, sql.c_str())))
		{
			MYSQL_ROW row;
			m_res = mysql_store_result(&m_sqlconnect);
			row = mysql_fetch_row(m_res);
			freeconnect();
			if (row == NULL)//查找不到
			{
				connect();
				string sql7 = "INSERT INTO imooc.sign (name,type,cat,addr,id) VALUES ('";
				string sql6 = "','";
				string sql5 = "')";
				string tem = to_string(namenumber);
				string sql4 = sql7 + token + sql6 + "0" + sql6 + "c" + sql6 + "-1" + sql6 + tem + sql5 + ";";//这里要改一下看一下是从第几个开始的 
				mysql_query(&m_sqlconnect, sql4.c_str());
				//freeconnect();
				cout << "(c," << namenumber << ")" << endl;
				Sign_item s;
				s.name = token;
				s.type = 3;
				s.cat = 'c';
				s.addr = Const_table.size();
				Sign_table.push_back(s);
				T t;
				t.t1 = 'c';
				t.t2 = namenumber;
				Token.push_back(t);
				Const_table.push_back(token);
				namenumber++;
			}
			else//这个就是找到了
			{
				connect();
				MYSQL_ROW row;
				mysql_query(&m_sqlconnect, sql.c_str());
				m_res = mysql_store_result(&m_sqlconnect);
				row = mysql_fetch_row(m_res);
				cout << "(c," << row[1] << ")" << endl;
				T t;
				t.t1 = 'c';
				t.t2 = int(atof(row[1]));
				Token.push_back(t);
			}
		}
		break;
	}
	case 8:       //判断字符 用不上
	{
		if (Whetherkeyword(token))
		{
			code1 = 4;
		}
		if (code1 == 0)		//不是关键字，是标识符
		{
			string sql3 = "SELECT * FROM imooc.sign WHERE name = ";
			string sql1 = "\'";
			string sql2 = "\'";
			string sql4 = ";";
			string sql = sql3 + sql2 + token + sql1 + sql4;
			connect();
			if (!(mysql_query(&m_sqlconnect, sql.c_str())))
			{
				MYSQL_ROW row;
				m_res = mysql_store_result(&m_sqlconnect);
				row = mysql_fetch_row(m_res);
				freeconnect();
				if (row == NULL)//查找不到
				{
					connect();
					string sql7 = "INSERT INTO imooc.sign (name) VALUES ('";
					string sql6 = "','";
					string sql5 = "')";
					//string tem = to_string(namenumber);
					//string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
					string sql4 = sql7 + token + sql5 + ";";
					mysql_query(&m_sqlconnect, sql4.c_str());
					//freeconnect();
					cout << "(i," << namenumber << ")" << endl;
					T t;
					t.t1 = 'i';
					t.t2 = namenumber;
					namenumber++;
					Token.push_back(t);
					Char_table.push_back(token[0]);
				}
				else//这个就是找到了
				{
					MYSQL_ROW row1;
					connect();
					if (!mysql_query(&m_sqlconnect, sql.c_str()))
					{
						m_res = mysql_store_result(&m_sqlconnect);
						row1 = mysql_fetch_row(m_res);
						if (row1 != NULL)
						{
							cout << "(i," << row1[1] << ")" << endl;
							T t;
							t.t1 = 'i';
							t.t2 = int(atof(row1[1]));
							Token.push_back(t);
						}
						else
						{
							cout << ERROR << endl;
						}
					}
					else
						cout << mysql_error(&m_sqlconnect);
				}
			}
			else
			{
				cout << mysql_error(&m_sqlconnect);
				freeconnect();
			}
		}
		break;
	}
	case 11:   //判断字符串 用不上
	{
		if (Whetherkeyword(token))
		{
			code1 = 4;
		}
		if (code1 == 0)		//不是关键字，是标识符
		{
			string sql3 = "SELECT * FROM imooc.sign WHERE name = ";
			string sql1 = "\'";
			string sql2 = "\'";
			string sql4 = ";";
			string sql = sql3 + sql2 + token + sql1 + sql4;
			connect();
			if (!(mysql_query(&m_sqlconnect, sql.c_str())))
			{
				MYSQL_ROW row;
				m_res = mysql_store_result(&m_sqlconnect);
				row = mysql_fetch_row(m_res);
				freeconnect();
				if (row == NULL)//查找不到
				{
					connect();
					string sql7 = "INSERT INTO imooc.sign (name) VALUES ('";
					string sql6 = "','";
					string sql5 = "')";
					//string tem = to_string(namenumber);
					//string sql4 = sql7 + token + sql6 + tem + sql5 + ";";//这里要改一下
					string sql4 = sql7 + token + sql5 + ";";
					mysql_query(&m_sqlconnect, sql4.c_str());
					//freeconnect();
					cout << "(i," << namenumber << ")" << endl;
					T t;
					t.t1 = 'i';
					t.t2 = namenumber;
					namenumber++;
					Token.push_back(t);
					String_table.push_back(token);
				}
				else//这个就是找到了
				{
					MYSQL_ROW row1;
					connect();
					if (!mysql_query(&m_sqlconnect, sql.c_str()))
					{
						m_res = mysql_store_result(&m_sqlconnect);
						row1 = mysql_fetch_row(m_res);
						if (row1 != NULL)
						{
							cout << "(i," << row1[1] << ")" << endl;
							T t;
							t.t1 = 'i';
							t.t2 = int(atof(row1[1]));
							Token.push_back(t);
						}
						else
						{
							cout << ERROR << endl;
						}
					}
					else
						cout << mysql_error(&m_sqlconnect);
				}
			}
			else
			{
				cout << mysql_error(&m_sqlconnect);
				freeconnect();
			}
		}
		break;
	}
	case 12:
	{
		if (Whethersp(token))
		{
			flagp = 1;
		}
		if (flagp == 0)
		{
			printf("Error!No such PT word!\n");
		}
		break;
	}
	default:
		printf("Sorry it's going wrong!");
	}
	return 0;
}
int main()
{
	state = 1;
	char infile[40];
	cin >>infile;
	if ((fp = fopen(infile, "r")) == NULL)
	{
		printf("NOT open file!\n");
		exit(1);
	}
	while ((ch = fgetc(fp)) != EOF)
	{
		state_before = state;
		state = state_change(state, ch);
		if (state == -1)
		{
			printf(" Error! \n");
		}
		else if (state != 0)
		{
			token[i++] = ch;
		}
		else
		{
			if (state_before != 1)
			{
				state_to_code(state_before, token);
			}
			memset(token, 0, 10);
			i = 0;
			state = 1;
		}
	}
	if (ch == EOF)
	{
		state_to_code(state, token);
	}
	PROGRAM();
	cout << "     Sign_table:" << endl;
	for (int i = 0; i < Sign_table.size(); i++) //输出符号表主表
	{
		cout << Sign_table[i].name << "," << Sign_table[i].type << ","
			<< Sign_table[i].cat << "," << Sign_table[i].addr << endl;
	}
	cout << "     QT:" << endl;
	for (int i = 0; i < QT.size(); i++)
	{
		cout << i << ". " << "(" << QT[i].w << "," << QT[i].o1 << "," << QT[i].o2 << "," << QT[i].t << ")" << endl;
	}
	if (flag == 1 && False == 0)
		cout << "Success!" << endl;
	else
		cout << "Fail!" << endl;
	return 0;
}



